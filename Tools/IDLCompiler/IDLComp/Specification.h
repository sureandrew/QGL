// Parsed informations from IDL file compilation
//
// Copyright 2004 Bae,Hyun-jik.  All rights reserved.
//
// Permission is granted to use this code for any purpose, as long as this
// copyright message remains intact.

#pragma once

#include <antlr/refcount.hpp>

using namespace antlr;

typedef unsigned long DWORD;

class CSpecification;
class CConfigurations;
class CConfiguration;
class CFunction;
class CParameter;
class CPreprocess;
class CAttribute;
class CClass;

//////////////////////////////////////////////////////////////////////////
// note that parsed information data are collected from class IDLParser.
// IDLParser is generated by compiling .g file.

/** parsed information data: IDL configuration */
class CConfiguration
{
public:
	string m_name; // Config variable name
	string m_value; // config variable value

	void SetName(string name);
	void SetIntValue(string value);
	void SetStrValue(string value);
};

/** parsed information data: IDL configuration list */
class CConfigurations
{
	typedef map<string, string> Configs;
	Configs m_configs;

public:
	unsigned int m_startID; // the first message identifier declared in IDL file.
	unsigned int m_endID; // the end message identifier declared in IDL file.
	int m_incID; // the incremented number for each RPC function declaration.

	CConfigurations();
	void AddConfig(CConfiguration *config);
	string GetConfig(string name);
	void SetConfig(string name, string value);
};

/** parsed information data: an RPC function declaration */
class CFunction
{
public:
	unsigned int m_ID;		// message identifier assigned to this RPC function. 
	string m_name;			// RPC function name
	bool m_isCb;			// is callback function
	bool m_implExist;		// implement exist
	bool m_public;			// is public
	bool m_block;			// is blocking
	unsigned short m_rpcid;	// generated rpc id
	unsigned int m_secret;	// generated secret number

	// RPC function parameters list

	CFunction() : m_isCb(false), m_implExist(false), 
				m_public(true), m_block(true), m_rpcid(0), m_secret(0) {}
	typedef vector<CParameter> Parameters; 
	Parameters m_params;

	void SetName(string name);
	void AddParameter(CParameter* param);
};

/** parsed information data: a RPC function parameter */
class CParameter
{
public:
	// parameter name and type name
	string m_name, m_type;
	string m_count;
	string m_rangeStart;
	string m_rangeEnd;
	string m_digits;
	bool   m_pointer;
	bool   m_ref;

	CParameter() : m_pointer(false), m_ref(false) {}
	void SetType(string type);
	void SetName(string name);
	void SetCount(string count);
	void SetRange(string stValue, string edValue);
	void SetDigits(string digit);
	void SetPointer(bool p) { m_pointer = p; }
	void SetReference(bool r) { m_ref = r; }
	bool IsPointer() { return m_pointer; }
	bool IsReference()  { return m_ref; }
};

/** parsed information data: a preprocess line */
class CPreprocess
{
public:
	// preprocess lines
	vector<string> m_lines;

	void AddLine(string line) {  m_lines.push_back(line); }
};

/** parsed information data: an RPC class attribute declaration */
class CAttribute
{
public:
	string m_name;	// RPC attribute name

	// RPC function parameters list
	typedef vector<CParameter> Fields;
	Fields m_fields;
	typedef vector<CAttribute> Attributes;
	Attributes m_childs;	// child attributes
	bool m_implExist;		// update attribute implement exist

	CAttribute() : m_implExist(false) {}
	void SetName(string name);
	void AddField(CParameter* field);
	void AddAttribute(CAttribute* attr);
	string GetMasks();
	bool CheckContain(string name);
	int NewAttrCount();
};

/** parsed information data: a RPC class */
class CClass
{
public:
	string m_name;
	string m_parent;
	// collected RPC method declarations
	typedef vector<CAttribute> Attributes;
	Attributes m_attrs;
	typedef vector<CFunction> Methods;
	Methods m_methods;
	bool m_public;		// is public or private for coming method?
	bool m_block;		// is blocking or unblocking for coming method?

	CClass();
	void SetName(string name);
	void SetParent(string parent);
	void SetPublic(bool bPublic) { m_public = bPublic; }
	void SetBlock(bool bBlock) { m_block = bBlock; }
	void AddAttribute(CAttribute* attr);
	void AddMethod(CFunction* method);
};

/** parsed information data: a typedef */
/*class CTypeDef
{
public:
	string m_type;

	CClass();
	void SetType(string stype);
};
*/


/** main of IDL parsing output */
class CSpecification
{
	// collected configuration variables 
	CConfigurations m_configurations;
public:
	// collected RPC function declarations
	string m_idlName;
	typedef vector<CFunction> Functions;
	Functions m_functions;
	Functions m_extraFuncs;
	CPreprocess m_preprocess;
	CClass m_class;
	string m_suffix;		// "Proxy" or "Stub"
	bool m_public;		// is public or private for coming function?
	bool m_block;		// is blocking or unblocking for coming function?

	CSpecification(void);
	~CSpecification(void);

	void SetConfigs(CConfigurations *configs);
	void AddFunction(CFunction* func);
	void SetClass(CClass* clas);
	void SetIdlName(string name) { m_idlName = name; }
	void SetPublic(bool bPublic) { m_public = bPublic; }
	void SetBlock(bool bBlock) { m_block = bBlock; }
	void AddPreprocess(string line) { m_preprocess.AddLine(line); }
	void AddTypeDef(string line) { m_preprocess.AddLine(line); }
	void AddStruct(string line) { m_preprocess.AddLine(line); }
	bool CheckFuncExist(string name);
	bool CheckAttrExist(string name);
	int NewFuncCount();
	int NewAttrCount();
	string GetConfig(string name) { return m_configurations.GetConfig(name); }
	void SetConfig(string name, string value) { return m_configurations.SetConfig(name, value); }
	int GetIdRange() { return m_configurations.m_endID - m_configurations.m_startID + 1; }
	unsigned int GetStartId() { return m_configurations.m_startID; }
	unsigned int GetEndId() { return m_configurations.m_endID; }
	bool IsClass() { return (m_class.m_name != ""); }
};

